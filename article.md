__성당과 시장__ (The Cathedral and the Bazaar)
================

Eric Steven Raymond

Copyright: Permission is granted to copy, distribute and/or modify this doucument under the terms of the Open Publication License, version 2.0.

__요약__
--------

성공적인 오픈 소스 프로젝트인 `fetchmail`에 대해서 분석한다. 이 프로젝트는 리눅스 역사에 의해 제시된 놀라운 소프트웨어 엔지니어링 이론을 신중하게 테스트하기 위해 실행된 것이다. 이 이론들을 근본적으로 두 가지 개발 스타일, 즉 상업 세계의 대부분의 대한 `성당`모델과 리눅스 세계의 `시장`모델의 관점에서 논할 것이다. 이 모델들이 소프트웨어 디버깅 작업의 본질에 대한 서로 대립되는 가설으로부터 파생된다는 것을 보일 것이다. 그리고 나서 “충분한 눈들이 있다면, 찾을 수 없는 버그는 없다”라는 제의를 위한 리눅스 경험에서 지속적인 논쟁을 만들었고 다른 이기적인 에이전트의 자가 정정 시스템과 함께 생산적인 비유를 제안했으며 미래의 소프트웨어를 위한 통찰력에 관한 결과의 탐구로 마무리짓는다.

__목차__
--------
* 성당과 시장
* 메일은 반드시 배달되어야만 한다.
* 사용자가 있다는 것의 중요성
* 일찍, 자주 발표하라.
* 얼마나 많은 눈들을 극복했을까
* 장미가 장미가 아닐때는?
* Popclient가 Fetchmail이 되다.
* Fetchmail의 성장
* Fetchmail에서 배울 점
* 시장 스타일에 필요한 전제 조건
* 오픈소스 소프트웨어의 사회적 맥락

<!-- Abstract -->

__1. 성당과 시장__
-----------------

리눅스는 파괴적이다. 5년 전 (1991년)만 해도 그 누가 세계 정상급 운영 체제가 이너넷을 통해 지구상의 흩어진 수천명의 개발자들이 파트타임으로 개조하여 마술처럼 융합 할 수 있다고 생각했을까요? 물론 나는 아닙니다. 리눅스가 나의 레이더 화면에 잡혔을 때는 1993년 쯤이며, 저는 이미 10년 동안 유닉스와 오픈소스 개발에 참여해 왔습니다. 저는 1980년 중반 최초의 GNU 기여자 중에 한 명입니다. 나는 많은 양의 오픈소스 소프트웨어를 인터넷에 공유했으며, 개발했거나 공동한 개발한 프로그램들은 (nethack, Emacs's VC and GUD 모드들, xlife와 기타 등등) 오늘날에도 전세계적으로 사용된다. 나는 프로그램이 어떻게 개발되어야 하는지 알고 있다고 생각했다.

리눅스는 내가 알고 있다고 생각한 많은 부분을 뒤집어 버렸다. 수 년 동안 나는 작은 도구, 빠른 프로토타이핑, 그리고 진화적인 프로그래밍을 여러 해 동안 유닉스의 복음으로 설교해 오고 있었다. 그러나 나는 어떠한 종류의 중요한 복잡성이 있어서 거기에 더 집중되고 선험적인 접근방법이 필요하다고 믿고 있었다. 가장 중요한 소프트웨어(운영체제나 Emacs 같이 엄청나게 큰 도구들)는 성당을 건축하듯이, 즉 찬란한 고독 속에서 일하는 몇 명의 프로그래머 귀재들이나 작은 그룹의 마법사들에 의해 조심스럽게 만들어지고 때가 되기 전에 출시되는 베타버전도 없어야 한다고 믿었다.

리누스 토발즈의 개발 스타일은 - 일찍, 그리고 자주 발표하며 다른 사람들에게 위임할 수 있는 것은 모두 위임하고, 난잡한 부분까지 공개하는 것 - 놀라움으로 다가왔다. 고요하고 신성한 성당의 건축은 찾아볼 수 없었으며, 리눅스 공동체는 서로 다른 의견과 접근방법이 난무하는 매우 소란스러운 시장같았다. (리눅스 아카이브 사이트가 상징하고있다. `누구나` 파일을 올릴 수 있다) 이런 곳에서 일관성있고 안정적인 시스팀이 나온다는 것은 외견상으로는 기적에 의해서 성공한 것으로 보인다.

시장 스타일이 작동하고 심지어 잘 작동한다는 사실은 분명한 충격으로 다가왔다. 내 주관대로 배우면서, 나는 개인 프로젝트만 열심히 했을 뿐만 아니라, 리눅스 세계가 혼돈에 의해 각각 분리되지 않고 성당 건설자들의 속도와 비슷하게 직진할 수 있었는가를 이해하려했다.

1996년 중반에야 내가 이해를 하기 시작했다고 생각했다. 내 이론을 완벽하게 시험해 볼 수 있는 기회가 오픈 소스 프로젝트의 형태로 찾아왔다. 그래서 나는 시험했고, 그것은 눈에 띄는 성공이었다.

위 글은 프로젝트의 스토리에 관한 내용이다. 나는 이 스토리를 효과적인 오픈소스 개발에 관한 몇 개의 격언을 제안하기 위해 사용할 것이다. 이 모든 것들은 내가 리눅스 세계에서 처음으로 배운 것은 아니지만, 리눅스 세계가 그들에게 특별한 점을 어떻게 제공하는지 보게 될 것이다. 만약 내가 맞는다면, 그들은 리눅스 공동체를 훌륭한 소프트웨어의 샘으로 만드는 것이 무엇인지 정확히 이해할 수 있게 도와 줄 것이며, 아마 여러분들이 스스로 더 생산적으로 될 수 있도록 도울 것입니다.

<!-- The Cathedral and the Bazaar -->

__2. 메일은 반드시 배달되어야만 한다.__
-------------------------------------

1993년에 나는 펜실베니아 주, 웨스트 체스터의 작은 무료 IPS인 체스터 카운티 인터링크 (Chester County InterLink)에서 기술적인 부분을 담당하고 있었다. 나는 CCIL의 공동 설립자였으며 우리의 고유한 멀티유저 게시판 소프트웨어를 작성했다. -- `locke.ccil.org`에 telnet을 통해 확인할 수 있다. 오늘날 이것은 3000명의 유저를 30개의 회선으로 지원할 수 있다. 이 일은 나에게 하루 24시간동안 CCIL의 56K 회선을 통해서 네트워크에 접속할 수 있도록 하였다. -- 사실, 그렇게 해야만 했다.

나는 인스턴트 인터넷 이메일에 익숙해 있었다. 나는 정기적으로 telnet 위에 있는 locke를 통해서 성가시게 나의 메일을 확인해야했다.  내가 원하는 것은 내 메일이 snark(나의 집 시스템)로 수신되면 내가 알수있고 로컬 도구들을 이용해 메일을 다룰 수 있게 되는 것이었다.

SMTP (Simple Mail Transfer Protocol)이라 불리는 인터넷의 기본적인 메일 포워딩 프로토콜은 내 요구사항에 맞지않았는데 컴퓨터가 상시 연결되어 있어야만 잘 작동했기 때문이다. 내 개인 컴퓨터는 항상 연결되어 있지 않았고 정적 아이피 주소를 가지고 있지도 않았다. 내가 필요한 것은 간헐적 다이얼 업 연결을 통해 내 메일들을 가정 컴퓨터로 배달되는 프로그램이었다. 나는 이미 이런것들이 있다는 것을 알았고 대부분은 POP (Post Office Protocol)이라 부르는 간단한 어플리케이션 프로토콜을 사용했었다. POP은 현재 대부분의 메일 클라이언트들을 지원하지만 당시에 내가 사용하던 메일 리더에는 내장되어 있지 않았다.

나는 POP3 클라이언트가 필요했었고 그래서 나는 인터넷에서 하나를 찾았다. 실질적으로, 3개에서 4개였다. 그것들 중에 하나를 잠시 사용했지만 그것은 분명한 특징을 놓치고 있었다. 가져온 메일에서 주소를 변경하여 답장을 보내는 기능이었다.

문제는 이것이었는데 locke 내에서 'joe'라는 이름을 가지고 있는 사람이 나에게 메일을 보낸다 가정했을때 만약 내가 snark로 메일을 가져오고 그것에 답장을 하려고 시도했을때 존재하지않은 snark 내에서 'joe'라는 이름으로 보내려고 한다. 문제를 해결하기 위해서는 `@ccil.org`를 수작업으로 붙어줘야하는데 이것은 심각한 문제가 되었다.

이것은 분명히 컴퓨터가 나를 위해 해야한다. 그러나 존재하는 어느 POP 클라이언트들 중에 이 방법을 알고있는 것은 없었다. 그리고 이러한 일들은 우리를 첫번째 교훈으로 이끈다.

__1. 모든 좋은 소프트웨어는 개발자 개인의 가려운 곳을 긁는 것으로부터 시작된다.__



<!-- The Mail Must Get Through -->

__3. 사용자가 있다는 것의 중요성__
--------------------------------

나는 popclient를 넘겨받았다. 동시에 popclient의 사용자들도 넘겨받았다.

__6. 사용자들을 공동개발자로서 생각한다면 코드가 다른 어떤 방법보다 빠른 속도로 개선되며 효율적으로 디버깅할 수 있다.__

이는 오픈소스 세계에서 리누스 토발즈가 명확하게 보여주었다.
나는 리누스가 했던 해킹중 가장 중요한 것은 리눅스 개발 모델을 만들었다는 점이라고 생각한다. 리눅스의 성공은 GNU Emacs Lisp 라이브러리와 Lisp 코드 아카이브에서 선례를 찾아볼 수 있는데, 이는 다른 성당건축 스타일과는 대조적으로 유동적이고 사용자가 주도하였다.  
이를 미루어 봤을때 내가 fetchmail 이전에 했던 가장 성공적인 해킹은 아마 Emacs VC 모드였을 것이다. 세 명의 사람들은 email을 통해 리눅스와 비슷한 협동작업을 하였고, 이를통한 VC의 개발은 Emacs와는 다르게 Emacs Lisp 코드가 발표/테스트/개선의 주기를 매우 빨리 반복할 수 있었기 때문에 성공하였다.  
코드를 법적으로 GPL(자유 소프트웨어 재단에서 만든 자유 소프트웨어 라이선스 - 엮은이)에 묶으려는 FSF(자유 소프트웨어 재단(Free Software Foundation) - 엮은이)의 정책은 시장모드를 사용하는 것을 절차적으로 까다롭게 만드는 부작용을 가져왔다. 그들은 GPL 코드를 저작권법 하에서의 도전으로부터 면역시키기 위해 20줄 이상의 개인적인 공헌에 대해서는 저작권을 주어야 한다고 믿기 때문이다.

<!-- The Importance of Having Users -->

__4. 일찍, 자주 발표하라.__
--------------------------
일찍, 그리고 자주 발표하는 것은 리눅스 개발 모델의 중요한 부분이다. 대부분의 개발자들은 (필자를 포함하여) 아주 사소한 프로젝트가 아니라면 이런 정책은 나쁜 것이라고 생각했다. 초기버전들은 예외없이 버그가 많고, 개발자라면 사용자들의 인내심을 시험하고 싶지는 않기 때문이다.

이런 믿음이 `성당건축(Cathedral)` 스타일의 개발을 더 선호하게 만들었다. 만일 가장 중요한 목표가 사용자들로 하여금 가능한 한 적은 버그를 발견하게 만드는 것이라면 6 개월에 한 번씩 (혹은 그보다 더 늦게) 발표하면서 그동안 죽어라고 일하는 편이 나을 것이다. Emacs C 코어는 이런 식으로 개발되었다. Lisp 라이브러리는 그렇지 않았다. Emacs 의 발표주기와 관계없이 언제든 새로운 개발 코드 버전을 찾을 수 있으며, FSF 의 통제권 밖에 있는 Lisp 라이브러리들이 있었기 때문이다.

이들 중 가장 중요한 아카이브는 오늘날 대형 리눅스 아카이브들의 정신과 많은 기능들을 이미 가지고 있었던 오하이오 주의 elisp 아카이브였다. 하지만 우리가 하고 있는 일에 대해, FSF 의 성당건축(Cathedral) 개발모델의 문제점들에 대해 그 아카이브의 존재가 무엇을 제시하는지에 대해 우리들 중 소수만이 진지하게 생각하고 있었다. 나는 1992년에 오하이오 코드를 공식적인 Emacs Lisp 라이브러리에 정식으로 병합시키려는 시도를 했으나 정치적인 문제에 부딪쳤고, 큰 실패를 겪었다.

1년 후에, 리눅스가 널리 알려지기 시작했고, 무언가 다르면서도 훨씬 바람직한 일이 일어나고 있다는 것이 확실해 보였다. 리누스의 열린 개발정책은 성당건축과 완전히 반대되는 것이었다. 선사이트와 tsx-11 아카이브가 싹트고 있었고, 다중배포방식이 퍼지기 시작했다. 그리고 이 모든 것이 들어보지 못한 방법의 자주 릴리즈 되는 코어시스템에 의해 주도되고 있었다.

리누스는 가장 효과적인 방식으로 사용자들을 공동개발자라고 여기고 있었던 것이다.   

__7. 일찍, 자주 발표하고, 소비자들에게 귀를 기울여라.__

리누스의 혁신은 그가 이렇게 했다는 점 보다는 (그 비슷한 것이 오랫동안 유닉스 세계의 전통이었다) 그가 개발하고 있던 리눅스 커널의 복잡성에 비견될만한 수준으로까지 끌어올렸다는 데 있다. 초기에 (1991년 경) 그는 하루에 한 번 이상 새로운 커널을 발표하기까지 했다. 리누스가 공동개발자들이라는 자신의 기반을 잘 만들었고, 인터넷이라는 지렛대를 이용하여 누구보다도 열심히 협동작업에 몰두했기 때문에 이런 방식은 성공했다.

하지만 어떤 과정을 거쳐 성공할 수 있었을까? 내가 재현할 수 있는 것일까, 아니면 리누스 토발즈만의 천재성이 필요한 것일까?

그렇게 생각되지는 않았다. 리누스가 매우 뛰어난 해커라는 점은 인정한다. (우리중에 상업용 제품 못지 않은 운영체제의 커널을 만들어낼 수 있는 사람이 몇이나 될까?) 하지만 리눅스는 놀랄만한 개념적 전진을 이루어내지는 않았다. 리누스는 리차드 스톨먼이나 제임스 고슬링 (NeWS 와 Java를 만든) 과 같은 혁신적인 설계를 이루어내는 천재는 (적어도 지금까지는) 아니었다. 대신 리누스는 공학의 천재인 것으로 보인다. 버그와 개발의 막다른 골목을 피하는 육감, 그리고 A 점에서 B 점까지 가는데 최소노력 경로를 찾아내는 요령을 갖추고 있었다. 실제로 리눅스의 전반적인 설계는 이런 특성을 바탕으로 하고 있으며 리누스의 본질적으로 보수적이고 단순한 설계 방식을 반영하고 있다.

따라서 빠른 릴리즈와 인터넷을 매체로 사용하는 것이 우연히 이루어진 것이 아니라 리누스의 공학적 천재성에 기인한 최소노력 경로에 대한 통찰력의 통합적인 부분이었다면 그가 최대화하고 있는 것은 무엇이었을까? 기계에서 무엇을 뽑아내었던 것일까?

해답은 질문 안에 있다. 리누스는 그의 해커/사용자들에게 지속적인 자극과 보답을 제공했다 -- 리눅스 개발에 참여함으로써 자기만족을 얻으리라는 전망에 자극받았고, 그들이 하는 일이 계속해서 (어떤 때는 날마다) 향상되고 있다는 것이 보답이 되었다.

리누스는 만일 처리하기 곤란한 심각한 버그가 발견되면 사용자들이 떨어져 나갈 위험과 코드가 불안정해질 가능성을 무릅쓰고 디버깅과 개발에 투입되는 공수(the number of person-hours)를 최대화 하는 것에 목표를 두었다. 리누스는 다음과 같은 신념을 가지고 있는 것처럼 행동했다.

__8. 충분히 많은 베타테스터와 공동개발자가 있으면 거의 모든 문제들은 빨리 파악될 것이고 쉽게 고치는 사람이 있게 마련이다.__

덜 형식적으로 말하자면, "보고 있는 눈이 충분히 많으면 찾지 못할 버그는 없다." 나는 이것을 `리누스의 법칙` 이라고 부른다.

내 원래의 공식적인 서술은 모든 문제는 "누군가에게는 간단할 것이다" 였다. 리누스는 문제를 이해하고 고치는 사람이 그 문제를 처음 파악한 사람과 항상 같은 것이 아니라 오히려 다른 경우가 더 많다고 이의를 제기했다. 리누스의 얘기로는, "누군가 문제를 발견합니다. 그리고 또다른 누군가가 그 문제를 이해하지요. 문제를 발견해 내는 것이 더 중요한 일이라고 분명히 말할 수 있습니다." 하지만 가장 중요한 점은 사람이 충분히 많을 경우 이 두 가지(발견하는 것과 고치는 것)가 모두 매우 빨리 일어나는 경향이 있다는 것이다.

내 생각에는 `리누스의 법칙` 에는 `성당 건축(The Cathedral)` 과 `시장 스타일(The Bazaar)` 의 핵심적인 차이점이 있다. 프로그래밍의 성당 건축가 관점에서 보자면 버그와 개발 문제는 어렵고, 까다로우며 심오한 현상이다. 문제를 해결하려면 헌신적인 소수의 사람이 몇 달이고 정밀한 검사를 수행해야 모두 끝났다는 확신을 가질 수 있다. 따라서 발표 사이의 기간이 길어지고, 오랫동안 기다린 릴리즈가 완벽하지 않을 때는 필연적으로 실망이 따른다.

반면, 시장의 관점에서는 버그가 보통 쉽게 해결될 수 있는 것이라고 본다 -- 최소한 새로운 릴리즈가 나올때마다 그것과 씨름하는 수천의 열정적인 공동개발자들에게 알려진다면 금방 쉽게 해결할 수 있는 문제로 바뀐다. 따라서 더 많이 교정을 받고 싶다면 자주 발표해야 하며 덤으로 서투른 부분이 드러나더라도 잃을 것이 적다는 이점이 있다.

바로 이것이다. 이것으로 충분하다. "리누스의 법칙" 이 틀렸다면 리눅스 커널과 같이 복잡한 시스템은 어떤 것이라도 수많은 손들에 의해 해킹되면서 일찍이 볼 수 없었던 나쁜 상호작용과 발견되지 못한 "심오한" 버그들에 의해 어느 시점에선가 붕괴되고 말았을 것이다. 반면에, 만일 그 법칙이 옳다면 그 법칙만으로도 리눅스의 상대적으로 적은 버그를 설명할 수 있다.

그리고 이 법칙이 옳다는 것에 대해서 너무 놀라지 말아야할 것이다. 수년 전, 사회학자들은 비슷하게 전문적인 (혹은 비슷하게 무지한) 관찰자들로 이루어진 대중의 평균적인 의견이 그 관찰자 중 무작위로 뽑은 한 명의 의견보다 더 신뢰할 만하다는 점을 발견했다. 사회학자들은 이것을 `델파이 효과` 라고 부른다. 이는 리누스가 보여준 것이 이 효과가 운영체제를 디버깅하는 데에도 적용될 수 있다는 점을 보여준다. - 델파이 효과는 OS 커널만큼 복잡한 개발까지도 다룰 수 있는 것이다.[CV](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#CV)

확실히 델파이 효과를 도와주는 리눅스의 상황의 한가지 특별한 특징은 어떠한 주어진 프로젝트의 기여자들은 그 프로젝트를 스스로 선택했다는 점이다. 응답자들은 기여자들이 랜덤 샘플로부터 수용된 것이 아닌 그 소프트웨어를 사용하고, 어떻게 작동하는지 배우고, 그들이 처한 문제의 답을 찾으려고 시도하고, 사실상 명확하게 합당한 수정을 제공할만큼 관심이 있는 사람들이라고 지적했다. 이 모든 필터를 거친 어떤사람이든 프로젝트에 기여하기에 유용한 어떤 것을 가지고 있을 것이다.

리누스법칙은 "디버깅은 병렬처리가 가능하다"라고 다르게 표현될 수 있다. 디버거들이 디버깅을 하려면 의사소통을 조정해주는 개발자가 필요하지만 디버거들 사이에는 그다지 조정이 필요하지 않다. 그러므로 개발자를 추가하는데서 생기는 기하급수적인 복잡성과 관리의 어려움이 디버깅에는 짐이 되지 않는다.

실제로 리눅스 세계에서는 디버거의 작업이 중복됨으로써 생기는 이론적인 효율 저하가 거의 문제되었던 적이 없는 것으로 보인다. "빨리, 그리고 자주 발표하는 정책" 의 효과 중 하나는 피드백되어 오는 수정사항을 빨리 전파함으로써 중복이 최소화된다는 것이다. [JH](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#JH)

브룩스(Brooks)(`The mythical Man-Month` 의 저자)는 즉석에서 다음과 같은 말을 했다. "널리 사용되는 프로그램의 유지보수에 들어가는 비용은 보통 개발시 드는 비용의 40 퍼센트나 그 이상입니다. 놀랍게도 이 비용은 사용자의 수에 큰 영향을 받습니다. 더 많은 사용자들이 더 많은 버그를 찾아냅니다."

사용자들이 많아지면 프로그램을 시험해보는 방법이 더 늘어나기 때문에 버그를 더 많이 잡아낼 수 있다. 이 효과는 사용자들이 공동개발자들일 때 더욱 커진다. 각 사람들이 버그를 찾아낼 때 조금씩 다른 개념의 집합과 분석 도구들을 사용하여 문제의 다른 각도에서 접근하기 때문이다. "델파이 효과" 는 바로 이런 편차에서 비롯되는 것으로 보인다. 또한 디버깅이라는 특정한 환경에서 이 편차는 노력의 중복을 줄여주는 경향이 있다.

따라서 더 많은 베타테스터를 가지는 것은 개발자의 관점에서 현재의 "가장 심오한" 버그의 복잡성을 줄여주지는 않을 테지만, 누군가의 도구가 문제에 딱 들어맞아 그 버그가 그 사람에게는 쉽게 잡을 수 있는 것이 될 가능성을 높여준다.

리누스도 물론 할 일이 있었다. 심각한 버그가 있을 경우에 대비해 리눅스 커널 버전은 잠재 사용자들이 최종적으로 "안정된" 버전을 사용할 수도 있고 새로운 기능을 사용하기 위해 최신의 버그가 있을 수 있는 버전을 사용할 수도 있게 번호가 붙여졌다. 이 전술은 아직까지 대부분의 리눅스 해커들이 따라하지는 않고 있지만 아마도 따라하게 될 것이다. 두 가지 선택이 가능하다는 사실이 양쪽 모두를 더 매력적으로 보이게 한다. [HBS](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#HBS)

<!-- Release Early, Release Often -->

얼마나 많은 눈이 문제를 지켜보는가
--------------------------------

시장 스타일이 디버깅과 코드 개발을 크게 가속화한다는 것은 전체적으로 보아야 할 한가지 사실입니다. 또한 이 방법을 통해 개발자와 테스터의 작업 방식과 그 이유를 마이크로 레벨에서 정확하게 이해할 수 있습니다. 이 섹션(원문으로 부터 3년 후 작성되었고, 원문을 읽고 개발 방식을 고친 개발자들이 고안하여 작성한 섹션입니다) 에서는 실제 작동 메커니즘을 자세히 살펴보겠습니다. 기술적면에 관심이 없는 독자는 다음 섹션으로 건너뛰셔도 무방합니다.

<!-- How Many Eyeballs Tame Complexity -->

<!-- When Is a Rose Not a Rose? -->



<!-- Popclient becomes Fetchmail -->



<!-- Fetchmail Grows Up -->



<!-- A Few More Lessons from Fetchmail -->



<!-- Necessary Preconditions for the Bazaar Style -->



<!-- The Social Context of Open-Source Software -->
