__성당과 시장__ (The Cathedral and the Bazaar)
================

Eric Steven Raymond

Copyright: Permission is granted to copy, distribute and/or modify this doucument under the terms of the Open Publication License, version 2.0.

__요약__
--------

성공적인 오픈 소스 프로젝트인 `fetchmail`에 대해서 분석한다. 이 프로젝트는 리눅스 역사에 의해 제시된 놀라운 소프트웨어 엔지니어링 이론을 신중하게 테스트하기 위해 실행된 것이다. 이 이론들을 근본적으로 두 가지 개발 스타일, 즉 상업 세계의 대부분의 대한 `성당`모델과 리눅스 세계의 `시장`모델의 관점에서 논할 것이다. 이 모델들이 소프트웨어 디버깅 작업의 본질에 대한 서로 대립되는 가설으로부터 파생된다는 것을 보일 것이다. 그리고 나서 “충분한 눈들이 있다면, 찾을 수 없는 버그는 없다”라는 제의를 위한 리눅스 경험에서 지속적인 논쟁을 만들었고 다른 이기적인 에이전트의 자가 정정 시스템과 함께 생산적인 비유를 제안했으며 미래의 소프트웨어를 위한 통찰력에 관한 결과의 탐구로 마무리짓는다.

__목차__
--------
* 성당과 시장
* 메일은 반드시 배달되어야만 한다.
* 사용자가 있다는 것의 중요성
* 일찍, 자주 발표하라.
* 얼마나 많은 눈들을 극복했을까
* 장미가 장미가 아닐때는?
* Popclient가 Fetchmail이 되다.
* Fetchmail의 성장
* Fetchmail에서 배울 점
* 시장 스타일에 필요한 전제 조건
* 오픈소스 소프트웨어의 사회적 맥락

<!-- Abstract -->

__1. 성당과 시장__
-----------------

리눅스는 파괴적이다. 5년 전 (1991년)만 해도 그 누가 세계 정상급 운영 체제가 이너넷을 통해 지구상의 흩어진 수천명의 개발자들이 파트타임으로 개조하여 마술처럼 융합 할 수 있다고 생각했을까요? 물론 나는 아닙니다. 리눅스가 나의 레이더 화면에 잡혔을 때는 1993년 쯤이며, 저는 이미 10년 동안 유닉스와 오픈소스 개발에 참여해 왔습니다. 저는 1980년 중반 최초의 GNU 기여자 중에 한 명입니다. 나는 많은 양의 오픈소스 소프트웨어를 인터넷에 공유했으며, 개발했거나 공동한 개발한 프로그램들은 (nethack, Emacs's VC and GUD 모드들, xlife와 기타 등등) 오늘날에도 전세계적으로 사용된다. 나는 프로그램이 어떻게 개발되어야 하는지 알고 있다고 생각했다.

리눅스는 내가 알고 있다고 생각한 많은 부분을 뒤집어 버렸다. 수 년 동안 나는 작은 도구, 빠른 프로토타이핑, 그리고 진화적인 프로그래밍을 여러 해 동안 유닉스의 복음으로 설교해 오고 있었다. 그러나 나는 어떠한 종류의 중요한 복잡성이 있어서 거기에 더 집중되고 선험적인 접근방법이 필요하다고 믿고 있었다. 가장 중요한 소프트웨어(운영체제나 Emacs 같이 엄청나게 큰 도구들)는 성당을 건축하듯이, 즉 찬란한 고독 속에서 일하는 몇 명의 프로그래머 귀재들이나 작은 그룹의 마법사들에 의해 조심스럽게 만들어지고 때가 되기 전에 출시되는 베타버전도 없어야 한다고 믿었다.

리누스 토발즈의 개발 스타일은 -- 일찍, 그리고 자주 발표하며 다른 사람들에게 위임할 수 있는 것은 모두 위임하고, 난잡한 부분까지 공개하는 것 -- 놀라움으로 다가왔다. 고요하고 신성한 성당의 건축은 찾아볼 수 없었으며, 리눅스 공동체는 서로 다른 의견과 접근방법이 난무하는 매우 소란스러운 시장같았다. (리눅스 아카이브 사이트가 상징하고있다. `누구나` 파일을 올릴 수 있다) 이런 곳에서 일관성있고 안정적인 시스팀이 나온다는 것은 외견상으로는 기적에 의해서 성공한 것으로 보인다.

시장 스타일이 작동하고 심지어 잘 작동한다는 사실은 분명한 충격으로 다가왔다. 내 주관대로 배우면서, 나는 개인 프로젝트만 열심히 했을 뿐만 아니라, 리눅스 세계가 혼돈에 의해 각각 분리되지 않고 성당 건설자들의 속도와 비슷하게 직진할 수 있었는가를 이해하려했다.

1996년 중반에야 내가 이해를 하기 시작했다고 생각했다. 내 이론을 완벽하게 시험해 볼 수 있는 기회가 오픈 소스 프로젝트의 형태로 찾아왔다. 그래서 나는 시험했고, 그것은 눈에 띄는 성공이었다.

위 글은 프로젝트의 스토리에 관한 내용이다. 나는 이 스토리를 효과적인 오픈소스 개발에 관한 몇 개의 격언을 제안하기 위해 사용할 것이다. 이 모든 것들은 내가 리눅스 세계에서 처음으로 배운 것은 아니지만, 리눅스 세계가 그들에게 특별한 점을 어떻게 제공하는지 보게 될 것이다. 만약 내가 맞는다면, 그들은 리눅스 공동체를 훌륭한 소프트웨어의 샘으로 만드는 것이 무엇인지 정확히 이해할 수 있게 도와 줄 것이며, 아마 여러분들이 스스로 더 생산적으로 될 수 있도록 도울 것입니다.

<!-- The Cathedral and the Bazaar -->

__2. 메일은 반드시 배달되어야만 한다.__
-------------------------------------

1993년에 나는 펜실베니아 주, 웨스트 체스터의 작은 무료 IPS인 체스터 카운티 인터링크 (Chester County InterLink)에서 기술적인 부분을 담당하고 있었다. 나는 CCIL의 공동 설립자였으며 우리의 고유한 멀티유저 게시판 소프트웨어를 작성했다. -- `locke.ccil.org`에 telnet을 통해 확인할 수 있다. 오늘날 이것은 3000명의 유저를 30개의 회선으로 지원할 수 있다. 이 일은 나에게 하루 24시간동안 CCIL의 56K 회선을 통해서 네트워크에 접속할 수 있도록 하였다. -- 사실, 그렇게 해야만 했다.

나는 인스턴트 인터넷 이메일에 익숙해 있었다. 나는 정기적으로 telnet 위에 있는 locke를 통해서 성가시게 나의 메일을 확인해야했다. 내가 원하는 것은 내 메일이 snark(나의 집 시스템)로 수신되면 내가 알수있고 로컬 도구들을 이용해 메일을 다룰 수 있게 되는 것이었다.

SMTP (Simple Mail Transfer Protocol)이라 불리는 인터넷의 기본적인 메일 포워딩 프로토콜은 내 요구사항에 맞지않았는데 컴퓨터가 상시 연결되어 있어야만 잘 작동했기 때문이다. 내 개인 컴퓨터는 항상 연결되어 있지 않았고 정적 아이피 주소를 가지고 있지도 않았다. 내가 필요한 것은 간헐적 다이얼 업 연결을 통해 내 메일들을 가정 컴퓨터로 배달되는 프로그램이었다. 나는 이미 이런것들이 있다는 것을 알았고 대부분은 POP (Post Office Protocol)이라 부르는 간단한 어플리케이션 프로토콜을 사용했었다. POP은 현재 대부분의 메일 클라이언트들을 지원하지만 당시에 내가 사용하던 메일 리더에는 내장되어 있지 않았다.

나는 POP3 클라이언트가 필요했었고 그래서 나는 인터넷에서 하나를 찾았다. 실질적으로, 3개에서 4개였다. 그것들 중에 하나를 잠시 사용했지만 그것은 분명한 특징을 놓치고 있었다. 가져온 메일에서 주소를 변경하여 답장을 보내는 기능이었다.

문제는 이것이었는데 locke 내에서 'joe'라는 이름을 가지고 있는 사람이 나에게 메일을 보낸다 가정했을때 만약 내가 snark로 메일을 가져오고 그것에 답장을 하려고 시도했을때 존재하지않은 snark 내에서 'joe'라는 이름으로 보내려고 한다. 문제를 해결하기 위해서는 `@ccil.org`를 수작업으로 붙어줘야하는데 이것은 심각한 문제가 되었다.

이것은 분명히 컴퓨터가 나를 위해 해야한다. 그러나 존재하는 어느 POP 클라이언트들 중에 이 방법을 알고있는 것은 없었다. 그리고 이러한 일들은 우리를 첫번째 교훈으로 이끈다.

__1. 모든 좋은 소프트웨어는 개발자 개인의 가려운 곳을 긁는 것으로부터 시작된다.__

명확해 보이는 교훈이긴 하지만 ("필요는 발명의 어머니" 라는 오래된 속담이 있다) 소프트웨어 개발자들은 너무 자주, 단지 돈 때문에 그들이 필요로 하지도 않고 좋아하지도 않는 프로그램을 만들어 내는데 시간을 쓰고 있다. 하지만 리눅스 세계에서는 그렇지 않다 -- 아마도 이것이 왜 리눅스 공동체에서 만들어진 소프트웨어들의 평균적이 품질이 그렇게나 좋은지를 설명해줄 것이다.

그래서 내가 이미 존재하는 POP3 클라이언트들과 경쟁하기 위해서 새로운 클라이언트들 곧바로 코딩하기 시작했을까? 천만에! 나는 이미 가지고 있는 POP 유틸리티들을 살피면서 스스로에게 물었다. "이 중에서 내가 원하는 것과 가장 가까운게 무엇일까?" 그 이유는

__2. 좋은 프로그래머들은 어떻게 작성해야하는지 알고 있다. 위대한 프로그래머는 무엇을 다시 작성해야하는지 알고 있다.__

내가 위대한 프로그래머가 되라는 말은 아니지만 흉내내려고했다. 위대한 프로그래머의 중요한 특징 중 하나는 건설적인 게으름이다. 그들은 들인 노력으로가 아니라 결과로 평가받는다는 것을 알고 있으며 완전한 무에서 시작하는 것보다는 좋은 부분적 해결법에서 시작하는 것이 거의 항상 더 쉽다는 것을 알고 있다.

리누스 토발즈를 예로 들자면 밑바닥부터 리눅스를 만들려하지 않았다. 대신 그는 PC 클론들을 위한 작은 유닉스와 같은 Minix의 아이디어와 코드를 재사용하는 것으로부터 시작했다. 결국 모든 Minix 코드는 사라지거나 새로 쓰여졌다 -- 하지만 Minix 의 코드가 남아있을 동안 그 코드는 나중에 Linux 가 될 어린 아기의 발판 역할을 했다.

똑같은 생각으로 나는 이미 있는 POP 유틸리티 중 코딩이 잘 되어있는 것을 찾아 개발의 기초로 사용하려 했다.

 Unix 세계의 소스 공유하는 전통은 소스 재사용에 대해 호의적이었다 (GNU 프로젝트가 Unix 자체에 대한 심각한 의혹에도 불구하고 Unix를 기본 OS로 선택한 이유였다). 리눅스 세계는 거의 기술적 한계에 다다를 때까지 이 전통을 받아들였다. 일반적으로 사용 가능한 오픈 소스가 수 테라바이트에 달했다. 그래서 리눅스 세계에서는 다른 어느 곳에서보다 누군가의 거의 완성된 소스를 찾아보는데 시간을 들이는 것이 좋은 결과를 가져다 줄 가능성이 높다.

 나에게도 역시 그랬다. 나는 Carl Harris의 popclient 코드가 눈에 띄었고 문제를 찾았다. fetchpop에는 훌륭한 독창적인 아이디어가 들어 있었지만 (백그라운드-데몬 모드와 같은 것) POP3만으로 처리할 수 있었고, 아마추어 티가 나는 코딩이었다. (오승홍씨는 똑똑하기는 하지만 경험이 부족한 프로그래머였으며 그 두가지 특징을 코등에서 볼 수 있었다). Carl의 코드는 전문가가 만든 탄탄하면서 더 나는 코드였으나 몇가지 중요하면서도 구현하기 위해서는 약간의 잔머리가 필요한 fetchpop의 기능들이 (내가 추가한 기능들을 포함해서) 빠져 있었다.

머물러 있을 것인가, 옮겨갈 것인가? 옮겨간다면 더 나은 개발기반을 위해 이미 해놓은 코딩을 포기해야만 했다.

옮겨가는데 실질적인 동기가 되었던 것은 다중 프로토콜 지원 여부였다. POP3 가 포스트-오피스 서버 프로토콜 중에서 가장 널리 쓰이는 것이긴 했지만 유일한 프로토콜은 아니었다. fetchpop 을 비롯하여 다른 경쟁자들은 POP2, RPOP, 또는 APOP 를 지원하지 않았고, 나는 당시에 재미삼아서 IMAP(Internet Message Access Protocol, 가장 최근에 고안되었으며 가장 강력한 우체국 프로토콜) 을 지원해 볼까 하는 생각을 가지고 있었다.

하지만 옮겨가는 것이 좋은 생각이라는 좀 더 이론적인 이유도 가지고 있었다. 리눅스를 알기 오래전에 배운 교훈이었다.

__3. "가지고 있는 것을 버릴 계획을 세우라; 어떻게든 버리게 될 것이다." (Fred Brooks, The Mythical Man-Month, Chapter 11)__

다른 말로 하자면, 첫 번째 해결책을 구현할 때까지 진짜 문제가 무엇인지 이해하지 못하는 경우가 종종 있다는 것이다. 두 번째가 되어서야 어떻게 하는 것이 옳은 것인지 충분히 알게 될 수 있따. 따라서 만약 올바른 방법을 찾고 싶다면 `최소한` 한 번은 처음부터 시작하는 것이었다.

fetchpop을 고친 것은 내 첫 시도였고 popclient로 변경했다.

1996년 6월 25일에 Carl Harris에게 내 첫 번째 popclient 패치들은 보낸 후, 나는 그가 popclient에 대한 흥미를 이미 잃었다는 것을 알게 되었다. 코딩이 좀 지저분했고, 자잘한 버그들이 널려있었다. 내가 수정해야 할 것이 많았고, 우리는 프로그램을 넘겨받는 것이 합리적이라는 데에 동의하게 되었다.

내가 알아차리지 못하는 새에 프로젝트는 차츰 궤도에 오르기 시작했다. 나는 이미 존재하고 있는 POP 클라이언트의 마이너 패치를 생각하는 것이 아니었다. 클라이언트 하나를 통채로 관리하고 있었으며 내 머리에서는 커다란 변화가 될 아이디어들이 솟아나고 있었다.

코드 공유를 장려하는 소프트웨어 문화에서는 이런 방식으로 프로젝트가 진화하기 마련이다. 이렇게 말할 수 있다.

__4. 만약 당신이 올바른 태도를 가지고 있으면, 흥미로운 문제들이 당신을 찾을 것이다.__

그러나 Carl Harris's의 태도가 훨씬 더 중요했다. 그는 이것을 이해하고 있었다.

__5. 프로그램에 흥미를 잃었다면, 당신의 마지막 의무는 능력있는 후임자에게 프로그램을 넘겨주는 것이다.__

토론할 필요도 없이 Carl과 가는 가장 좋은 해결책을 찾고 있다는 것을 알고 있었다. 우리에게 남아있는 한가지 문제는 내가 적임자라는 것을 입증할 수 있느냐 하는 것이었다. 내가 그것을 증명하자 그는 기꺼이, 그리고 신석하게 행동했다. 내가 그렇게 내 차례가 되었을 때 나도 그만큼 잘 할 수 있기를 바란다.

<!-- The Mail Must Get Through -->

__3. 사용자가 있다는 것의 중요성__
--------------------------------

나는 popclient를 넘겨받았다. 동시에 popclient의 사용자들도 넘겨받았다.

__6. 사용자들을 공동개발자로서 생각한다면 코드가 다른 어떤 방법보다 빠른 속도로 개선되며 효율적으로 디버깅할 수 있다.__

이는 오픈소스 세계에서 리누스 토발즈가 명확하게 보여주었다.
나는 리누스가 했던 해킹중 가장 중요한 것은 리눅스 개발 모델을 만들었다는 점이라고 생각한다. 리눅스의 성공은 GNU Emacs Lisp 라이브러리와 Lisp 코드 아카이브에서 선례를 찾아볼 수 있는데, 이는 다른 성당건축 스타일과는 대조적으로 유동적이고 사용자가 주도하였다.  
이를 미루어 봤을때 내가 fetchmail 이전에 했던 가장 성공적인 해킹은 아마 Emacs VC 모드였을 것이다. 세 명의 사람들은 email을 통해 리눅스와 비슷한 협동작업을 하였고, 이를통한 VC의 개발은 Emacs와는 다르게 Emacs Lisp 코드가 발표/테스트/개선의 주기를 매우 빨리 반복할 수 있었기 때문에 성공하였다.  
코드를 법적으로 GPL(자유 소프트웨어 재단에서 만든 자유 소프트웨어 라이선스 - 엮은이)에 묶으려는 FSF(자유 소프트웨어 재단(Free Software Foundation) - 엮은이)의 정책은 시장모드를 사용하는 것을 절차적으로 까다롭게 만드는 부작용을 가져왔다. 그들은 GPL 코드를 저작권법 하에서의 도전으로부터 면역시키기 위해 20줄 이상의 개인적인 공헌에 대해서는 저작권을 주어야 한다고 믿기 때문이다.

<!-- The Importance of Having Users -->

__4. 일찍, 자주 발표하라.__
--------------------------
일찍, 그리고 자주 발표하는 것은 리눅스 개발 모델의 중요한 부분이다. 대부분의 개발자들은 (필자를 포함하여) 아주 사소한 프로젝트가 아니라면 이런 정책은 나쁜 것이라고 생각했다. 초기버전들은 예외없이 버그가 많고, 개발자라면 사용자들의 인내심을 시험하고 싶지는 않기 때문이다.

이런 믿음이 `성당건축(Cathedral)` 스타일의 개발을 더 선호하게 만들었다. 만일 가장 중요한 목표가 사용자들로 하여금 가능한 한 적은 버그를 발견하게 만드는 것이라면 6 개월에 한 번씩 (혹은 그보다 더 늦게) 발표하면서 그동안 죽어라고 일하는 편이 나을 것이다. Emacs C 코어는 이런 식으로 개발되었다. Lisp 라이브러리는 그렇지 않았다. Emacs 의 발표주기와 관계없이 언제든 새로운 개발 코드 버전을 찾을 수 있으며, FSF 의 통제권 밖에 있는 Lisp 라이브러리들이 있었기 때문이다.

이들 중 가장 중요한 아카이브는 오늘날 대형 리눅스 아카이브들의 정신과 많은 기능들을 이미 가지고 있었던 오하이오 주의 elisp 아카이브였다. 하지만 우리가 하고 있는 일에 대해, FSF 의 성당건축(Cathedral) 개발모델의 문제점들에 대해 그 아카이브의 존재가 무엇을 제시하는지에 대해 우리들 중 소수만이 진지하게 생각하고 있었다. 나는 1992년에 오하이오 코드를 공식적인 Emacs Lisp 라이브러리에 정식으로 병합시키려는 시도를 했으나 정치적인 문제에 부딪쳤고, 큰 실패를 겪었다.

1년 후에, 리눅스가 널리 알려지기 시작했고, 무언가 다르면서도 훨씬 바람직한 일이 일어나고 있다는 것이 확실해 보였다. 리누스의 열린 개발정책은 성당건축과 완전히 반대되는 것이었다. 선사이트와 tsx-11 아카이브가 싹트고 있었고, 다중배포방식이 퍼지기 시작했다. 그리고 이 모든 것이 들어보지 못한 방법의 자주 릴리즈 되는 코어시스템에 의해 주도되고 있었다.

리누스는 가장 효과적인 방식으로 사용자들을 공동개발자라고 여기고 있었던 것이다.   

__7. 일찍, 자주 발표하고, 소비자들에게 귀를 기울여라.__

리누스의 혁신은 그가 이렇게 했다는 점 보다는 (그 비슷한 것이 오랫동안 유닉스 세계의 전통이었다) 그가 개발하고 있던 리눅스 커널의 복잡성에 비견될만한 수준으로까지 끌어올렸다는 데 있다. 초기에 (1991년 경) 그는 하루에 한 번 이상 새로운 커널을 발표하기까지 했다. 리누스가 공동개발자들이라는 자신의 기반을 잘 만들었고, 인터넷이라는 지렛대를 이용하여 누구보다도 열심히 협동작업에 몰두했기 때문에 이런 방식은 성공했다.

하지만 어떤 과정을 거쳐 성공할 수 있었을까? 내가 재현할 수 있는 것일까, 아니면 리누스 토발즈만의 천재성이 필요한 것일까?

그렇게 생각되지는 않았다. 리누스가 매우 뛰어난 해커라는 점은 인정한다. (우리중에 상업용 제품 못지 않은 운영체제의 커널을 만들어낼 수 있는 사람이 몇이나 될까?) 하지만 리눅스는 놀랄만한 개념적 전진을 이루어내지는 않았다. 리누스는 리차드 스톨먼이나 제임스 고슬링 (NeWS 와 Java를 만든) 과 같은 혁신적인 설계를 이루어내는 천재는 (적어도 지금까지는) 아니었다. 대신 리누스는 공학의 천재인 것으로 보인다. 버그와 개발의 막다른 골목을 피하는 육감, 그리고 A 점에서 B 점까지 가는데 최소노력 경로를 찾아내는 요령을 갖추고 있었다. 실제로 리눅스의 전반적인 설계는 이런 특성을 바탕으로 하고 있으며 리누스의 본질적으로 보수적이고 단순한 설계 방식을 반영하고 있다.

따라서 빠른 릴리즈와 인터넷을 매체로 사용하는 것이 우연히 이루어진 것이 아니라 리누스의 공학적 천재성에 기인한 최소노력 경로에 대한 통찰력의 통합적인 부분이었다면 그가 최대화하고 있는 것은 무엇이었을까? 기계에서 무엇을 뽑아내었던 것일까?

해답은 질문 안에 있다. 리누스는 그의 해커/사용자들에게 지속적인 자극과 보답을 제공했다 -- 리눅스 개발에 참여함으로써 자기만족을 얻으리라는 전망에 자극받았고, 그들이 하는 일이 계속해서 (어떤 때는 날마다) 향상되고 있다는 것이 보답이 되었다.

리누스는 만일 처리하기 곤란한 심각한 버그가 발견되면 사용자들이 떨어져 나갈 위험과 코드가 불안정해질 가능성을 무릅쓰고 디버깅과 개발에 투입되는 공수(the number of person-hours)를 최대화 하는 것에 목표를 두었다. 리누스는 다음과 같은 신념을 가지고 있는 것처럼 행동했다.

__8. 충분히 많은 베타테스터와 공동개발자가 있으면 거의 모든 문제들은 빨리 파악될 것이고 쉽게 고치는 사람이 있게 마련이다.__

덜 형식적으로 말하자면, "보고 있는 눈이 충분히 많으면 찾지 못할 버그는 없다." 나는 이것을 `리누스의 법칙` 이라고 부른다.

내 원래의 공식적인 서술은 모든 문제는 "누군가에게는 간단할 것이다" 였다. 리누스는 문제를 이해하고 고치는 사람이 그 문제를 처음 파악한 사람과 항상 같은 것이 아니라 오히려 다른 경우가 더 많다고 이의를 제기했다. 리누스의 얘기로는, "누군가 문제를 발견합니다. 그리고 또다른 누군가가 그 문제를 이해하지요. 문제를 발견해 내는 것이 더 중요한 일이라고 분명히 말할 수 있습니다." 하지만 가장 중요한 점은 사람이 충분히 많을 경우 이 두 가지(발견하는 것과 고치는 것)가 모두 매우 빨리 일어나는 경향이 있다는 것이다.

내 생각에는 `리누스의 법칙` 에는 `성당 건축(The Cathedral)` 과 `시장 스타일(The Bazaar)` 의 핵심적인 차이점이 있다. 프로그래밍의 성당 건축가 관점에서 보자면 버그와 개발 문제는 어렵고, 까다로우며 심오한 현상이다. 문제를 해결하려면 헌신적인 소수의 사람이 몇 달이고 정밀한 검사를 수행해야 모두 끝났다는 확신을 가질 수 있다. 따라서 발표 사이의 기간이 길어지고, 오랫동안 기다린 릴리즈가 완벽하지 않을 때는 필연적으로 실망이 따른다.

반면, 시장의 관점에서는 버그가 보통 쉽게 해결될 수 있는 것이라고 본다 -- 최소한 새로운 릴리즈가 나올때마다 그것과 씨름하는 수천의 열정적인 공동개발자들에게 알려진다면 금방 쉽게 해결할 수 있는 문제로 바뀐다. 따라서 더 많이 교정을 받고 싶다면 자주 발표해야 하며 덤으로 서투른 부분이 드러나더라도 잃을 것이 적다는 이점이 있다.

바로 이것이다. 이것으로 충분하다. "리누스의 법칙" 이 틀렸다면 리눅스 커널과 같이 복잡한 시스템은 어떤 것이라도 수많은 손들에 의해 해킹되면서 일찍이 볼 수 없었던 나쁜 상호작용과 발견되지 못한 "심오한" 버그들에 의해 어느 시점에선가 붕괴되고 말았을 것이다. 반면에, 만일 그 법칙이 옳다면 그 법칙만으로도 리눅스의 상대적으로 적은 버그를 설명할 수 있다.

그리고 이 법칙이 옳다는 것에 대해서 너무 놀라지 말아야할 것이다. 수년 전, 사회학자들은 비슷하게 전문적인 (혹은 비슷하게 무지한) 관찰자들로 이루어진 대중의 평균적인 의견이 그 관찰자 중 무작위로 뽑은 한 명의 의견보다 더 신뢰할 만하다는 점을 발견했다. 사회학자들은 이것을 `델파이 효과` 라고 부른다. 이는 리누스가 보여준 것이 이 효과가 운영체제를 디버깅하는 데에도 적용될 수 있다는 점을 보여준다. - 델파이 효과는 OS 커널만큼 복잡한 개발까지도 다룰 수 있는 것이다.[CV](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#CV)

확실히 델파이 효과를 도와주는 리눅스의 상황의 한가지 특별한 특징은 어떠한 주어진 프로젝트의 기여자들은 그 프로젝트를 스스로 선택했다는 점이다. 응답자들은 기여자들이 랜덤 샘플로부터 수용된 것이 아닌 그 소프트웨어를 사용하고, 어떻게 작동하는지 배우고, 그들이 처한 문제의 답을 찾으려고 시도하고, 사실상 명확하게 합당한 수정을 제공할만큼 관심이 있는 사람들이라고 지적했다. 이 모든 필터를 거친 어떤사람이든 프로젝트에 기여하기에 유용한 어떤 것을 가지고 있을 것이다.

리누스법칙은 "디버깅은 병렬처리가 가능하다"라고 다르게 표현될 수 있다. 디버거들이 디버깅을 하려면 의사소통을 조정해주는 개발자가 필요하지만 디버거들 사이에는 그다지 조정이 필요하지 않다. 그러므로 개발자를 추가하는데서 생기는 기하급수적인 복잡성과 관리의 어려움이 디버깅에는 짐이 되지 않는다.

실제로 리눅스 세계에서는 디버거의 작업이 중복됨으로써 생기는 이론적인 효율 저하가 거의 문제되었던 적이 없는 것으로 보인다. "빨리, 그리고 자주 발표하는 정책" 의 효과 중 하나는 피드백되어 오는 수정사항을 빨리 전파함으로써 중복이 최소화된다는 것이다. [JH](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#JH)

브룩스(Brooks)(`The mythical Man-Month` 의 저자)는 즉석에서 다음과 같은 말을 했다. "널리 사용되는 프로그램의 유지보수에 들어가는 비용은 보통 개발시 드는 비용의 40 퍼센트나 그 이상입니다. 놀랍게도 이 비용은 사용자의 수에 큰 영향을 받습니다. 더 많은 사용자들이 더 많은 버그를 찾아냅니다."

사용자들이 많아지면 프로그램을 시험해보는 방법이 더 늘어나기 때문에 버그를 더 많이 잡아낼 수 있다. 이 효과는 사용자들이 공동개발자들일 때 더욱 커진다. 각 사람들이 버그를 찾아낼 때 조금씩 다른 개념의 집합과 분석 도구들을 사용하여 문제의 다른 각도에서 접근하기 때문이다. "델파이 효과" 는 바로 이런 편차에서 비롯되는 것으로 보인다. 또한 디버깅이라는 특정한 환경에서 이 편차는 노력의 중복을 줄여주는 경향이 있다.

따라서 더 많은 베타테스터를 가지는 것은 개발자의 관점에서 현재의 "가장 심오한" 버그의 복잡성을 줄여주지는 않을 테지만, 누군가의 도구가 문제에 딱 들어맞아 그 버그가 그 사람에게는 쉽게 잡을 수 있는 것이 될 가능성을 높여준다.

리누스도 물론 할 일이 있었다. 심각한 버그가 있을 경우에 대비해 리눅스 커널 버전은 잠재 사용자들이 최종적으로 "안정된" 버전을 사용할 수도 있고 새로운 기능을 사용하기 위해 최신의 버그가 있을 수 있는 버전을 사용할 수도 있게 번호가 붙여졌다. 이 전술은 아직까지 대부분의 리눅스 해커들이 따라하지는 않고 있지만 아마도 따라하게 될 것이다. 두 가지 선택이 가능하다는 사실이 양쪽 모두를 더 매력적으로 보이게 한다. [HBS](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#HBS)

<!-- Release Early, Release Often -->

__5.얼마나 많은 눈이 문제를 지켜보는가__
--------------------------------------

시장 스타일이 디버깅과 코드 개발을 크게 가속화한다는 것은 전체적으로 보아야 할 한가지 사실입니다. 또한 이 방법을 통해 개발자와 테스터의 작업 방식과 그 이유를 마이크로 레벨에서 정확하게 이해할 수 있습니다. 이 섹션(원문으로 부터 3년 후 작성되었고, 원문을 읽고 개발 방식을 고친 개발자들이 고안하여 작성한 섹션입니다) 에서는 실제 작동 메커니즘을 자세히 살펴보겠습니다. 기술적면에 관심이 없는 독자는 다음 섹션으로 건너뛰셔도 무방합니다.

한가지 알고 가야할 점은, 프로그램 내부 구조를 모르는 사용자들의 버그 리포트가 어째서 그리 유용하지 않은지 정확히 파악해야 한다는 것입니다. 내부 구조를 모르는 사용자들은 대부분이 겉으로 드러나는 현상에 대해서만 보고합니다. 그들은 자신들의 사용 환경이 일반적이라 생각해서 (a) 중요한 백그라운드 데이터를 생략하고 (b) 버그를 재현하기 위한 방법에 대해 거의 보고하질 않습니다.

여기서 보이는 근본적인 문제는 테스터와 프로그램 개발자의 사고방식이 일치하지 않는다는 점입니다. 테스터는 외부적인 면을 보고, 개발자는 내부적인 면을 봅니다. 클로즈드 소스 개발을 하다 보면 그들 모두 한가지 면에만 얽매이는 경향이 있고, 서로의 전적에 대해 이야기하면서 서로 깊은 좌절감을 느꼈다는 것을 알게 됩니다.

오픈 소스 개발은 이러한 문제점을 타개 할 수 있습니다. 오픈소스를 통해 테스터와 개발자들이 실제 소스 코드를 기반으로 효과적으로 소통하고 서로 생각하는 바를 뚜렷하게 공유할 수 있습니다. 사실상, 사용자가 프로그램의 표면적인 면만 볼 수 있던 것과 개발자의 소스 코드 속 생각까지 들여다 볼 수 있는 것은 버그 리포트를 만들때 커다란 차이가 있습니다.

대부분의 버그는, 대부분의 경우에, 사용자의 오류 환경에 대해 소스 코드 수준으로 표현해주면 표현이 완전하지 않고 암시적이더라도 쉽게 파악할 수 있습니다. 베타 테스터가 "어떤어떤 라인에 바운더리 문제가 있습니다."라고 하거나 또는 그냥 "X, Y, Z 조건하에 이 변수가 문제가 될 수 있습니다."는 식의 지적을 해주면 빠르게 코드를 살펴보고 곧바로 문제 해결에 착수할 수 있습니다.

따라서, 둘의 소스코드에 대한 공통된 인식은 베타 테스터의 보고와 핵심 개발자가 알고있는 것 사이에 훌륭한 소통과 시너지를 이끌어냅니다. 즉, 많은 협력자들과 함께하더라도 핵심 개발자들의 시간은 낭비되지 않는다는 의미입니다.

개발자의 시간을 절약해주는 오픈 소스의 또 다른 특징은 오픈소스 프로젝트의 의사소통 구조입니다. 위에서 "핵심 개발자"라는 표현을 사용했는데, 이는 프로젝트 코어(대체로 수가 적고, 일반적으로 한명이며, 주로 한명에서 세명 사이)와 베타 테스터 및 후원자(주로 그 수가 수백에 이르는)와 같은 프로젝트 할로 사이의 차이를 나타내기 위함입니다.

전통적인 소프트웨어 개발 조직의 근원적 문제점은 "Brook's Law", 즉 프로그래머가 많을 수록 프로젝트 완성시기가 늦어진다는 것 입니다.  일반적으로, 브룩의 법칙은 개발자의 수가 늘어남에 따라 작업은 산술급수적으로 증가하는 반면에 프로젝트의 복잡성과 커뮤니케이션 비용은 기하급수적으로 커진다는 사실을 알려줍니다.

클러스터의 인터페이스 코드를 서로 다른 사람이 작성하는 사이에 버그가 매우 자주 발생하며 커뮤니케이션/조정 오버헤드는 사람 사이의 수많은 인터페이스로 인해 발생한다는 경험적인 사실을 기반으로 브룩의 법칙이 만들어졌습니다. 즉, 문제의 규모는 개발자의 수의 제곱에 비례하는 가능한 의사소통 가짓수에 따라 커집니다.(좀더 정확하게는 개발자의 수가 N명일 때 N*(N-1)/2 공식을 따릅니다.)

브룩의 법칙에 대한 분석(개발집단의 많은 수의 개발자들에 대한 걱정)은 프로젝트 커뮤니케이션 구조가 모든 각각의 사람들이 서로 간에 소통하는 완전한 그래프 형태라는 가정에 기반합니다. 하지만 오픈 소스 프로젝트에서 할로 개발자들은 서로간에 영향이 거의 없는 병렬적이고 분리가능한 일을 수행한다. 코드 수정과 버그 리포트는 핵심그룹을 통해 전달되고, 오로지 그 작은 규모의 핵심 그룹 내에서만 브룩시안 오버헤드 비용이 발생하게 됩니다

소스코드 수준의 버그 리포트가 매우 효율적인 이유는 또 있습니다. 하나의 오류가 사용자의 사용 패턴 및 이용환경에 따라 어려가지 증상을 보일 수 있다는 사실에 초점을 맞춥니다. 이런 오류들은 정확히 원하는 대로 재현하거나 정적 분석을 통해 해결하기 가장 어려운, 복잡하고 미묘한 종류의 오류(dynamic-memory-management error 또는 nondeterministic interrupt-window artifacts 과 같은)이며, 소프트웨어에서 장기적인 문제를 발생시킵니다.

그러한 multi-symptom 버그에 대해 소스코드 수준의 시험적인 서술(예를 들면 "1250번째 줄의 신호 처리에 보안 문제가 있는것 같아요"라던가 "그 버퍼를 어디서 초기화했나요?" 같은)을 보내는 테스터는 개발자에게 이질적인 증상에 대한 절반짜리 중요한 단서를 제공해줍니다. 이러한 경우에, 버그로 인해 어떤 외부적인 증상이 발생할지는 모르지만, 그건 딱히 알 필요가 없습니다. 다른 협력자들이 그들의 버그가 고쳐졌는지의 여부를 빠르게 알아낼 수 있을 것입니다. 많은 경우의 소스코드 레벨의 버그 리포트는 특별한 해결책을 제시하지 않을 수도 있습니다.

복잡한 multi-symptom 에러는 겉으로 드러나는 증상에서 실제 버그까지의 추적 경로도 다양합니다. 개발자나 테스터가 추적할 수 있는지의 여부는 개인 환경의 세부사항에 따라 달라질 수 있고, 결정론적인 방식이 아닐 수도 있습니다. 실제로, 각 개발자와 테스터는 증상의 인과 관계를 찾을 때 프로그램의 설정 상태를 반무작위적으로 조정합니다. 버그가 더 미묘하고 복잡할수록, 이런 기술을 통해 샘플과의 관련성이 보장될 확률이 낮아집니다.

단순하고 쉽게 재확인할 수 있는 버그의 경우에, "무작위"가 아닌 "반"에 더 강조를 줍니다. 이때 코드와 그것의 구조에 관한 디버깅 스킬과 정교함이 크게 영향을 미칩니다. 하지만 복잡한 버그의 경우에는 "무작위"가 더 중요합니다. 이러한 상황에서는 많은 수의 사람들이 버그를 추적하는 것이 상대적으로 수준이 높은 소수의 사람들이 순차적으로 추적해보는 것보다 훨씬 효과적일 것입니다.

만일 서로다른 표면적인 증상에서 버그에 이르기 까지의 경로를 추적하는 어려움이 증상을 보고 예측할 수 없는 방식으로 두드러지게 진행된다면 이 효과는 크게 증폭됩니다. 순차적으로 버그를 파악하는 식의 한 개발자의 첫번째 시도는 어려운 방식의 추적 경로를 골라버릴 가능성이 있습니다. 반면에 소스를 빠르게 공개 하면서 많은 사람이 다양한 추적 경로를 파악한다고 가정합시다. 그러면 확률적으로 그들 중 한명은 가장 쉬운 길을 곧바로 찾아버릴 것이고, 훨씬 짧은 시간 안에 그 방법을 채택할 수 있습니다. 프로젝트 관리자는 그것을 통해 새로운 버전을 제공하고 다른 사람들이 똑같은 버그에 대해 더 어려운 방법으로 시간을 들이는 것을 멈출 수 있습니다.

<!-- How Many Eyeballs Tame Complexity -->
__5. 장미가 장미다우려면__
-------------------------

리누스의 행동을 연구하고 그것이 왜 성공적이었는지에 대한 이론을 만든 후, 나는 이 이론을 내 새로운 프로젝트 (물론 훨씬 덜 복잡하고 덜 야심적인 프로젝트) 에 적용해 보기로 했습니다.

그러나 내가 가장 먼저 한 일은 popclient 를 더 재조직화하고 단순화한 것이었습니다. 칼 해리스의 구현방식은 매우 유효한 것이었지만, 많은 C 프로그래머들에게서 볼 수 있었던 것처럼 불필요한 복잡성이 있었습니다. 그는 코드를 핵심적인 것으로, 자료구조는 코드를 받쳐주는 것으로 취급했습니다. 그 결과 코드는 아름답지만 자료구조는 ad-hoc으로 설계되었고, 보기에 좋지 않았습니다. (최소한 옛 LISP 해커의 높은 기준에서 보자면 말이다)

코드와 자료구조를 개선하는 것 말고도 나는 또다른 목적을 가지고 있었습니다. 그건 코드를 내가 완전히 이해하는 무엇인가로 진화시키는 것이었습니다. 이해하지 못하는 프로그램의 버그를 수정하는 책임을 맡는 것은 재미없는 일이었습니다.

처음 한달 정도가 지날 동안 나는 그저 칼의 기본적인 설계가 어떤 의미를 가지고 있는지 따라다니기만 했습니다. 내가 처음으로 중요한 수정을 진행한 것은 IMAP 지원이었습니다. 프로토콜 머신을 일반적인 드라이버와 세가지 메소드 테이블 (POP2, POP3, IMAP을 지원하는)로 재조직했습니다. 이와 그 이전의 변경들은 프로그래머들이 알아둘 만한 일반적인 원리를 보여줍니다. 특히 C 와 같이 즉흥적으로 프로그래밍하기 힘든 언어에서 말입니다.

__9. 자료구조를 훌륭하게 만들고 코드를 멍청하게 만드는 것이 그 반대의 경우보다 훨씬 잘 작동한다.__
브룩스의 책 9장 에 이렇게 쓰여있습니다. "내게 순서도를 보여주고 표를 숨긴다면 나는 계속 어리둥절할 것이다. 표를 보여준다면 순서도는 볼 필요도 없이 뻔한 것이다." 하지만 30년간 변해온 용어들과 문화를 고려한다면 거의 똑같은 말이라고 할 수 있습니다.

이 시점에서 (1996년 9월 초, 일을 시작하고 6 주가 지난 후) 나는 이름을 바꿀 때가 되었다고 생각하기 시작했습니다. 이 프로그램은 더 이상 단순한 POP client가 아니었다. 하지만 디자인에 완전히 새로운 것은 들어가 있지 않았기 때문에 나는 머뭇거리고 있었습니다. 내가 만든 popclient는 아직 스스로의 정체성을 확립하지 못하고 있었습니다.

fetchmail이 어떻게 SMTP 포트로 가져온 메일을 이동시켜야 하는지 알고 난 후에는 상황이 급변했습니다. 그에 대해서는 나중에 말하겠습니다. 하지만 그보다 먼저, 앞서 나는 리누스 토발즈가 옳은 방식으로 일을 해냈다는 내 이론을 시험하기 위해 이 프로젝트를 수행하기로 했다고 말했습니다. 어떻게 시험을 했을까? 다음과 같은 방법을 사용했습니다.

일찍, 자주 발표했습니다. (발표간격이 10일을 넘는 경우는 거의 없었으며 개발에 몰두해 있을 때는 하루에 한번씩 발표했다)

fetchmail 에 대한 일로 나에게 연락해 오는 사람은 누구든지 베타테스터 목록에 올렸습니다.

새로 발표할 때마다 베타테스터들에게 떠들썩하게 발표를 알리며 사람들이 참여하도록 격려했습니다.

그리고 그들의 이야기를 들었습니다. 설계 결정에 대해 투표를 하기도 했고 패치나 피드백을 보내올 때마다 베타테스터들을 구슬렀습니다.

이 단순한 방법들은 즉각 효력을 나타냈다. 프로젝트를 시작할 때부터 개발자들이라면 학수고대할 만한 버그 리포트를, 때로는 훌륭하게 수정된 코드를 받을 수 있었다. 사려깊은 비판과 팬 메일, 기능제안들을 받았다. 여기서 다음과 같은 결론을 이끌어 낼 수 있다.

__10. 베타테스터들을 가장 중요한 자원으로 여긴다면 그들은 정말 가장 중요한 자원이 되어준다.__

fetchmail 의 성공을 재는 재미있는 척도 중 하나는 프로젝트 베타테스터 메일링리스트인 fetchmail-friends 의 크기이다. 이 글을 쓰고있을 때 목록에는 249 명이 있었고 1주일에 2~3명이 추가되었다.

1997 년 5월말 경에 글을 수정하면서 보니까 목록은 300명 가까이 되었고, 멤버들이 조금씩 줄기 시작했는데 그 이유가 흥미로왔다. 몇몇 사람들이 구독을 중단하면서 fetchmail 이 잘 작동하기 때문에 더 이상 메일링리스트를 보고 있을 이유가 없다고 말했다. 아마 이것이 성숙한 시장 스타일의 프로젝트가 가지는 정상적인 라이프사이클 중 하나일 것이다.

<!-- When Is a Rose Not a Rose? -->



<!-- Popclient becomes Fetchmail -->



<!-- Fetchmail Grows Up -->



<!-- A Few More Lessons from Fetchmail -->



<!-- Necessary Preconditions for the Bazaar Style -->



<!-- The Social Context of Open-Source Software -->
