__성당과 시장__ (The Cathedral and the Bazaar)
================

Eric Steven Raymond

Copyright: Permission is granted to copy, distribute and/or modify this doucument under the terms of the Open Publication License, version 2.0.

__요약__
--------

성공적인 오픈 소스 프로젝트인 `fetchmail`에 대해서 분석한다. 이 프로젝트는 리눅스 역사에 의해 제시된 놀라운 소프트웨어 엔지니어링 이론을 신중하게 테스트하기 위해 실행된 것이다. 이 이론들을 근본적으로 두 가지 개발 스타일, 즉 상업 세계의 대부분의 대한 `성당`모델과 리눅스 세계의 `시장`모델의 관점에서 논할 것이다. 이 모델들이 소프트웨어 디버깅 작업의 본질에 대한 서로 대립되는 가설으로부터 파생된다는 것을 보일 것이다. 그리고 나서 “충분한 눈들이 있다면, 찾을 수 없는 버그는 없다”라는 제의를 위한 리눅스 경험에서 지속적인 논쟁을 만들었고 다른 이기적인 에이전트의 자가 정정 시스템과 함께 생산적인 비유를 제안했으며 미래의 소프트웨어를 위한 통찰력에 관한 결과의 탐구로 마무리짓는다.

__목차__
--------
* 성당과 시장
* 메일은 반드시 배달되어야만 한다.
* 사용자가 있다는 것의 중요성
* 일찍, 자주 발표하라.
* 얼마나 많은 눈들을 극복했을까
* 장미가 장미가 아닐때는?
* Popclient가 Fetchmail이 되다.
* Fetchmail의 성장
* Fetchmail에서 배울 점
* 시장 스타일에 필요한 전제 조건
* 오픈소스 소프트웨어의 사회적 맥락

<!-- Abstract -->

__성당과 시장__
--------------

리눅스는 파괴적이다. 5년 전 (1991년)만 해도 그 누가 세계 정상급 운영 체제가 이너넷을 통해 지구상의 흩어진 수천명의 개발자들이 파트타임으로 개조하여 마술처럼 융합 할 수 있다고 생각했을까요? 물론 나는 아닙니다. 리눅스가 나의 레이더 화면에 잡혔을 때는 1993년 쯤이며, 저는 이미 10년 동안 유닉스와 오픈소스 개발에 참여해 왔습니다. 저는 1980년 중반 최초의 GNU 기여자 중에 한 명입니다. 나는 많은 양의 오픈소스 소프트웨어를 인터넷에 공유했으며, 개발했거나 공동한 개발한 프로그램들은 (nethack, Emacs's VC and GUD 모드들, xlife와 기타 등등) 오늘날에도 전세계적으로 사용된다. 나는 프로그램이 어떻게 개발되어야 하는지 알고 있다고 생각했다.

리눅스는 내가 알고 있다고 생각한 많은 부분을 뒤집어 버렸다. 수 년 동안 나는 작은 도구, 빠른 프로토타이핑, 그리고 진화적인 프로그래밍을 여러 해 동안 유닉스의 복음으로 설교해 오고 있었다. 그러나 나는 어떠한 종류의 중요한 복잡성이 있어서 거기에 더 집중되고 선험적인 접근방법이 필요하다고 믿고 있었다. 가장 중요한 소프트웨어(운영체제나 Emacs 같이 엄청나게 큰 도구들)는 성당을 건축하듯이, 즉 찬란한 고독 속에서 일하는 몇 명의 프로그래머 귀재들이나 작은 그룹의 마법사들에 의해 조심스럽게 만들어지고 때가 되기 전에 출시되는 베타버전도 없어야 한다고 믿었다.

리누스 토발즈의 개발 스타일은 - 일찍, 그리고 자주 발표하며 다른 사람들에게 위임할 수 있는 것은 모두 위임하고, 난잡한 부분까지 공개하는 것 - 놀라움으로 다가왔다. 고요하고 신성한 성당의 건축은 찾아볼 수 없었으며, 리눅스 공동체는 서로 다른 의견과 접근방법이 난무하는 매우 소란스러운 시장같았다. (리눅스 아카이브 사이트가 상징하고있다. `누구나` 파일을 올릴 수 있다) 이런 곳에서 일관성있고 안정적인 시스팀이 나온다는 것은 외견상으로는 기적에 의해서 성공한 것으로 보인다.

시장 스타일이 작동하고 심지어 잘 작동한다는 사실은 분명한 충격으로 다가왔다. 내 주관대로 배우면서, 나는 개인 프로젝트만 열심히 했을 뿐만 아니라, 리눅스 세계가 혼돈에 의해 각각 분리되지 않고 성당 건설자들의 속도와 비슷하게 직진할 수 있었는가를 이해하려했다.

1996년 중반에야 내가 이해를 하기 시작했다고 생각했다. 내 이론을 완벽하게 시험해 볼 수 있는 기회가 오픈 소스 프로젝트의 형태로 찾아왔다. 그래서 나는 시험했고, 그것은 눈에 띄는 성공이었다.

위 글은 프로젝트의 스토리에 관한 내용이다. 나는 이 스토리를 효과적인 오픈소스 개발에 관한 몇 개의 격언을 제안하기 위해 사용할 것이다. 이 모든 것들은 내가 리눅스 세계에서 처음으로 배운 것은 아니지만, 리눅스 세계가 그들에게 특별한 점을 어떻게 제공하는지 보게 될 것이다. 만약 내가 맞는다면, 그들은 리눅스 공동체를 훌륭한 소프트웨어의 샘으로 만드는 것이 무엇인지 정확히 이해할 수 있게 도와 줄 것이며, 아마 여러분들이 스스로 더 생산적으로 될 수 있도록 도울 것입니다.

<!-- The Cathedral and the Bazaar -->



<!-- The Mail Must Get Through -->



<!-- The Importance of Having Users -->
**3. 사용자가 있다는 것의 중요성**
----
나는 popclient를 넘겨받았다. 동시에 popclient의 사용자들도 넘겨받았다.  
**6. 사용자들을 공동개발자로서 생각한다면 코드가 다른 어떤 방법보다 빠른 속도로 개선되며 효율적으로 디버깅할 수 있다.**  
이는 오픈소스 세계에서 리누스 토발즈가 명확하게 보여주었다.
나는 리누스가 했던 해킹중 가장 중요한 것은 리눅스 개발 모델을 만들었다는 점이라고 생각한다. 리눅스의 성공은 GNU Emacs Lisp 라이브러리와 Lisp 코드 아카이브에서 선례를 찾아볼 수 있는데, 이는 다른 성당건축 스타일과는 대조적으로 유동적이고 사용자가 주도하였다.  
이를 미루어 봤을때 내가 fetchmail 이전에 했던 가장 성공적인 해킹은 아마 Emacs VC 모드였을 것이다. 세 명의 사람들은 email을 통해 리눅스와 비슷한 협동작업을 하였고, 이를통한 VC의 개발은 Emacs와는 다르게 Emacs Lisp 코드가 발표/테스트/개선의 주기를 매우 빨리 반복할 수 있었기 때문에 성공하였다.  
코드를 법적으로 GPL(자유 소프트웨어 재단에서 만든 자유 소프트웨어 라이선스 - 엮은이)에 묶으려는 FSF(자유 소프트웨어 재단(Free Software Foundation) - 엮은이)의 정책은 시장모드를 사용하는 것을 절차적으로 까다롭게 만드는 부작용을 가져왔다. 그들은 GPL 코드를 저작권법 하에서의 도전으로부터 면역시키기 위해 20줄 이상의 개인적인 공헌에 대해서는 저작권을 주어야 한다고 믿기 때문이다.



<!-- Release Early, Release Often -->
**4. 일찍, 자주 발표하라.**  
----
일찍, 그리고 자주 발표하는 것은 리눅스 개발 모델의 중요한 부분이다. 대부분의 개발자들은 (필자를 포함하여) 아주 사소한 프로젝트가 아니라면 이런 정책은 나쁜 것이라고 생각했다. 초기버전들은 예외없이 버그가 많고, 개발자라면 사용자들의 인내심을 시험하고 싶지는 않기 때문이다.

이런 믿음이 **성당건축(Cathedral)** 스타일의 개발을 더 선호하게 만들었다. 만일 가장 중요한 목표가 사용자들로 하여금 가능한 한 적은 버그를 발견하게 만드는 것이라면 6 개월에 한 번씩 (혹은 그보다 더 늦게) 발표하면서 그동안 죽어라고 일하는 편이 나을 것이다. Emacs C 코어는 이런 식으로 개발되었다. Lisp 라이브러리는 그렇지 않았다. Emacs 의 발표주기와 관계없이 언제든 새로운 개발 코드 버전을 찾을 수 있으며, FSF 의 통제권 밖에 있는 Lisp 라이브러리들이 있었기 때문이다.

이들 중 가장 중요한 아카이브는 오늘날 대형 리눅스 아카이브들의 정신과 많은 기능들을 이미 가지고 있었던 오하이오 주의 elisp 아카이브였다. 하지만 우리가 하고 있는 일에 대해, FSF 의 성당건축(Cathedral) 개발모델의 문제점들에 대해 그 아카이브의 존재가 무엇을 제시하는지에 대해 우리들 중 소수만이 진지하게 생각하고 있었다. 나는 1992년에 오하이오 코드를 공식적인 Emacs Lisp 라이브러리에 정식으로 병합시키려는 시도를 했으나 정치적인 문제에 부딪쳤고, 큰 실패를 겪었다.

1년 후에, 리눅스가 널리 알려지기 시작했고, 무언가 다르면서도 훨씬 바람직한 일이 일어나고 있다는 것이 확실해 보였다. 리누스의 열린 개발정책은 성당건축과 완전히 반대되는 것이었다. 선사이트와 tsx-11 아카이브가 싹트고 있었고, 다중배포방식이 퍼지기 시작했다. 그리고 이 모든 것이 들어보지 못한 방법의 자주 릴리즈 되는 코어시스템에 의해 주도되고 있었다.

리누스는 가장 효과적인 방식으로 사용자들을 공동개발자라고 여기고 있었던 것이다.   

**7. 일찍, 자주 발표하고, 소비자들에게 귀를 기울여라.**

리누스의 혁신은 그가 이렇게 했다는 점 보다는 (그 비슷한 것이 오랫동안 유닉스 세계의 전통이었다) 그가 개발하고 있던 리눅스 커널의 복잡성에 비견될만한 수준으로까지 끌어올렸다는 데 있다. 초기에 (1991년 경) 그는 하루에 한 번 이상 새로운 커널을 발표하기까지 했다. 리누스가 공동개발자들이라는 자신의 기반을 잘 만들었고, 인터넷이라는 지렛대를 이용하여 누구보다도 열심히 협동작업에 몰두했기 때문에 이런 방식은 성공했다.

하지만 어떤 과정을 거쳐 성공할 수 있었을까? 내가 재현할 수 있는 것일까, 아니면 리누스 토발즈만의 천재성이 필요한 것일까?

그렇게 생각되지는 않았다. 리누스가 매우 뛰어난 해커라는 점은 인정한다. (우리중에 상업용 제품 못지 않은 운영체제의 커널을 만들어낼 수 있는 사람이 몇이나 될까?) 하지만 리눅스는 놀랄만한 개념적 전진을 이루어내지는 않았다. 리누스는 리차드 스톨먼이나 제임스 고슬링 (NeWS 와 Java를 만든) 과 같은 혁신적인 설계를 이루어내는 천재는 (적어도 지금까지는) 아니었다. 대신 리누스는 공학의 천재인 것으로 보인다. 버그와 개발의 막다른 골목을 피하는 육감, 그리고 A 점에서 B 점까지 가는데 최소노력 경로를 찾아내는 요령을 갖추고 있었다. 실제로 리눅스의 전반적인 설계는 이런 특성을 바탕으로 하고 있으며 리누스의 본질적으로 보수적이고 단순한 설계 방식을 반영하고 있다.

따라서 빠른 릴리즈와 인터넷을 매체로 사용하는 것이 우연히 이루어진 것이 아니라 리누스의 공학적 천재성에 기인한 최소노력 경로에 대한 통찰력의 통합적인 부분이었다면 그가 최대화하고 있는 것은 무엇이었을까? 기계에서 무엇을 뽑아내었던 것일까?

해답은 질문 안에 있다. 리누스는 그의 해커/사용자들에게 지속적인 자극과 보답을 제공했다 -- 리눅스 개발에 참여함으로써 자기만족을 얻으리라는 전망에 자극받았고, 그들이 하는 일이 계속해서 (어떤 때는 날마다) 향상되고 있다는 것이 보답이 되었다.

리누스는 만일 처리하기 곤란한 심각한 버그가 발견되면 사용자들이 떨어져 나갈 위험과 코드가 불안정해질 가능성을 무릅쓰고 디버깅과 개발에 투입되는 공수(the number of person-hours)를 최대화 하는 것에 목표를 두었다. 리누스는 다음과 같은 신념을 가지고 있는 것처럼 행동했다.

**8. 충분히 많은 베타테스터와 공동개발자가 있으면 거의 모든 문제들은 빨리 파악될 것이고 쉽게 고치는 사람이 있게 마련이다.**


덜 형식적으로 말하자면, ''보고 있는 눈이 충분히 많으면 찾지 못할 버그는 없다.'' 나는 이것을 **리누스의 법칙** 이라고 부른다.

내 원래의 공식적인 서술은 모든 문제는 ''누군가에게는 간단할 것이다'' 였다. 리누스는 문제를 이해하고 고치는 사람이 그 문제를 처음 파악한 사람과 항상 같은 것이 아니라 오히려 다른 경우가 더 많다고 이의를 제기했다. 리누스의 얘기로는, ''누군가 문제를 발견합니다. 그리고 또다른 누군가가 그 문제를 이해하지요. 문제를 발견해 내는 것이 더 중요한 일이라고 분명히 말할 수 있습니다.'' 하지만 가장 중요한 점은 사람이 충분히 많을 경우 이 두 가지(발견하는 것과 고치는 것)가 모두 매우 빨리 일어나는 경향이 있다는 것이다.

내 생각에는 **리누스의 법칙** 에는 **성당 건축(The Cathedral)** 과 **시장 스타일(The Bazaar)** 의 핵심적인 차이점이 있다. 프로그래밍의 성당 건축가 관점에서 보자면 버그와 개발 문제는 어렵고, 까다로우며 심오한 현상이다. 문제를 해결하려면 헌신적인 소수의 사람이 몇 달이고 정밀한 검사를 수행해야 모두 끝났다는 확신을 가질 수 있다. 따라서 발표 사이의 기간이 길어지고, 오랫동안 기다린 릴리즈가 완벽하지 않을 때는 필연적으로 실망이 따른다.

반면, 시장의 관점에서는 버그가 보통 쉽게 해결될 수 있는 것이라고 본다 -- 최소한 새로운 릴리즈가 나올때마다 그것과 씨름하는 수천의 열정적인 공동개발자들에게 알려진다면 금방 쉽게 해결할 수 있는 문제로 바뀐다. 따라서 더 많이 교정을 받고 싶다면 자주 발표해야 하며 덤으로 서투른 부분이 드러나더라도 잃을 것이 적다는 이점이 있다.

바로 이것이다. 이것으로 충분하다. ''리누스의 법칙'' 이 틀렸다면 리눅스 커널과 같이 복잡한 시스템은 어떤 것이라도 수많은 손들에 의해 해킹되면서 일찍이 볼 수 없었던 나쁜 상호작용과 발견되지 못한 ''심오한'' 버그들에 의해 어느 시점에선가 붕괴되고 말았을 것이다. 반면에, 만일 그 법칙이 옳다면 그 법칙만으로도 리눅스의 상대적으로 적은 버그를 설명할 수 있다.

그리고 이 법칙이 옳다는 것에 대해서 너무 놀라지 말아야할 것이다. 수년 전, 사회학자들은 비슷하게 전문적인 (혹은 비슷하게 무지한) 관찰자들로 이루어진 대중의 평균적인 의견이 그 관찰자 중 무작위로 뽑은 한 명의 의견보다 더 신뢰할 만하다는 점을 발견했다. 사회학자들은 이것을 *델파이 효과* 라고 부른다. 이는 리누스가 보여준 것이 이 효과가 운영체제를 디버깅하는 데에도 적용될 수 있다는 점을 보여준다. - 델파이 효과는 OS 커널만큼 복잡한 개발까지도 다룰 수 있는 것이다.[CV](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#CV)

확실히 델파이 효과를 도와주는 리눅스의 상황의 한가지 특별한 특징은 어떠한 주어진 프로젝트의 기여자들은 그 프로젝트를 스스로 선택했다는 점이다. 응답자들은 기여자들이 랜덤 샘플로부터 수용된 것이 아닌 그 소프트웨어를 사용하고, 어떻게 작동하는지 배우고, 그들이 처한 문제의 답을 찾으려고 시도하고, 사실상 명확하게 합당한 수정을 제공할만큼 관심이 있는 사람들이라고 지적했다. 이 모든 필터를 거친 어떤사람이든 프로젝트에 기여하기에 유용한 어떤 것을 가지고 있을 것이다.

리누스법칙은 ''디버깅은 병렬처리가 가능하다''라고 다르게 표현될 수 있다. 디버거들이 디버깅을 하려면 의사소통을 조정해주는 개발자가 필요하지만 디버거들 사이에는 그다지 조정이 필요하지 않다. 그러므로 개발자를 추가하는데서 생기는 기하급수적인 복잡성과 관리의 어려움이 디버깅에는 짐이 되지 않는다.

실제로 리눅스 세계에서는 디버거의 작업이 중복됨으로써 생기는 이론적인 효율 저하가 거의 문제되었던 적이 없는 것으로 보인다. ''빨리, 그리고 자주 발표하는 정책'' 의 효과 중 하나는 피드백되어 오는 수정사항을 빨리 전파함으로써 중복이 최소화된다는 것이다. [JH](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#JH)

브룩스(Brooks)(*The mythical Man-Month* 의 저자)는 즉석에서 다음과 같은 말을 했다. ''널리 사용되는 프로그램의 유지보수에 들어가는 비용은 보통 개발시 드는 비용의 40 퍼센트나 그 이상입니다. 놀랍게도 이 비용은 사용자의 수에 큰 영향을 받습니다. *더 많은 사용자들이 더 많은 버그를 찾아냅니다*.

사용자들이 많아지면 프로그램을 시험해보는 방법이 더 늘어나기 때문에 버그를 더 많이 잡아낼 수 있다. 이 효과는 사용자들이 공동개발자들일 때 더욱 커진다. 각 사람들이 버그를 찾아낼 때 조금씩 다른 개념의 집합과 분석 도구들을 사용하여 문제의 다른 각도에서 접근하기 때문이다. ''델파이 효과'' 는 바로 이런 편차에서 비롯되는 것으로 보인다. 또한 디버깅이라는 특정한 환경에서 이 편차는 노력의 중복을 줄여주는 경향이 있다.

따라서 더 많은 베타테스터를 가지는 것은 개발자의 관점에서 현재의 ''가장 심오한'' 버그의 복잡성을 줄여주지는 않을 테지만, 누군가의 도구가 문제에 딱 들어맞아 그 버그가 그 사람에게는 쉽게 잡을 수 있는 것이 될 가능성을 높여준다.

리누스도 물론 할 일이 있었다. 심각한 버그가 있을 경우에 대비해 리눅스 커널 버전은 잠재 사용자들이 최종적으로 ''안정된'' 버전을 사용할 수도 있고 새로운 기능을 사용하기 위해 최신의 버그가 있을 수 있는 버전을 사용할 수도 있게 번호가 붙여졌다. 이 전술은 아직까지 대부분의 리눅스 해커들이 따라하지는 않고 있지만 아마도 따라하게 될 것이다. 두 가지 선택이 가능하다는 사실이 양쪽 모두를 더 매력적으로 보이게 한다. [HBS](http://www.catb.org/%7Eesr/writings/cathedral-bazaar/cathedral-bazaar/ar01s14.html#HBS)



<!-- How Many Eyeballs Tame Complexity -->
얼마나 많은 눈이 문제를 지켜보는가
--------------------------------

시장 스타일이 디버깅과 코드 개발을 크게 가속화한다는 것은 전체적으로 보아야 할 한가지 사실입니다. 또한 이 방법을 통해 개발자와 테스터의 작업 방식과 그 이유를 마이크로 레벨에서 정확하게 이해할 수 있습니다. 이 섹션(원문으로 부터 3년 후 작성되었고, 원문을 읽고 개발 방식을 고친 개발자들이 고안하여 작성한 섹션입니다) 에서는 실제 작동 메커니즘을 자세히 살펴보겠습니다. 기술적면에 관심이 없는 독자는 다음 섹션으로 건너뛰셔도 무방합니다.


<!-- When Is a Rose Not a Rose? -->



<!-- Popclient becomes Fetchmail -->



<!-- Fetchmail Grows Up -->
__Fetchmail의 성장__
----
이제는 깔끔하고 혁신적인 설계, 매일 사용하므로 잘 작동하는 것을 알고 있는 코드, 발전하고 있는 베타테스터의 목록을 가지고 있었다. 더이상 내가 하고 있는 일이 몇몇의 사람에게 유용할 수도 있는 사소하고 개인적인 해킹은 아니라는 생각이 서서히 들기 시작했다. 내가 가지고 있는 것은 유닉스 박스와 SLIP/PPP 메일 연결을 가지고 있는 모든 해커들이 정말로 필요로 하는 프로그램이었다.
SMTP 포워딩 기능으로 fetchmail 은 경쟁에서 멀찍이 앞서나와 카테고리 킬러, 그러니까 해당분야의 다른 프로그램들은 아예 잊혀져 버릴 만한 경쟁력을 갖추고 자신의 지위를 확고하게 하는 고전적인 프로그램이 될 수 있는 능력을 갖추었다.
이런 결과를 계획하거나 목표로 가질 수는 없으리라고 생각한다. 아주 강력한 설계상의 아이디어로 그런 결과가 불가피하고, 자연스러우며 운명적인 것으로 보이게 함으로써 그런 결과에 도달해야 한다. 그런 아이디어를 구체화해 볼 수 있는 유일한 방법은 수많은 아이디어를 가지는 것이다. 아니면 다른 사람들의 좋은 아이디어를, 원래 생각되었던 것보다 더 멀리 이끌고 가서 구체화 시켜보는 방법이다.
앤드류 타넨바움 (Andrew Tanenbaum) 은 교습 도구로 사용하기 위해 386용으로 간단한 네이티브 유닉스를 만들려는 원래의 아이디어를 가지고 있었다. 리누스 토발즈는 이 미닉스의 개념을 앤드류가 생각했던 것보다 더 멀리 밀고 나갔다. 그래서 리눅스는 굉장한 것이 되었다. 똑같은 방식으로 (더 작은 스케일이었지만) 나는 칼 해리스와 해리 호흐하이저의 아이디어들을 가져와 강하게 밀어붙였다. 리누스나 나나 사람들이 천재들이 그러하리라고 생각하는 낭만적인 의미에서 `독창적' 인 것은 아니었다. 하지만 통념과는 반대로 대부분의 과학과 공학과 소프트웨어 개발은 독창적인 천재, 해커의 전설에 의해서 이루어지지는 않는다.
결과물은 똑같이 매우 사람을 흥분시키는 것들이다  사실, 모든 해커들은 이런 종류의 성공을 얻기 위해 살아간다! 거기에는 내가 기준을 더 높이 잡아야 한다는 의미도 들어있다. fetchmail을 최상의 것으로 만들기 위해 나는 내자신의 필요뿐 아니라 나와는 상관없지만 다른 사람들에게는 필수적인 기능을 포함시키고 지원해야했다. 게다가 프로그램을 단순하고 튼튼하게 유지시키면서 그런 일을 해야 했다.
이것을 깨닫고 나서 내가 추가한 매우 중요한 첫 번째 기능은 멀티드롭(multidrop) 기능이었다. 그룹이나 사용자들의 메일을 한꺼번에 가지고 있는 메일박스에서 메일을 가져와 각 메일들을 개인 수신자에게 라우트(route) 시켜주는 기능이었다.
멀티드롭 기능을 추가하기로 한 데에는 몇몇 사용자들이 원한다는 것도 있었지만 가장 큰 이유는 어드레싱을 완전히 구현함으로써 싱글드롭 코드에 있는 버그들을 잡아낼 수 있으리라고 생각했기 때문이다. 그리고 그렇게 되었다. RFC 822의 파싱을 제대로 구현하는 것에 매우 오랜 시간이 걸렸는데, 각각의 조각이 어려웠기 때문이 아니라 각각이 서로 의존하고 있으며 세심하게 신경을 써야 하는 사항들이었기 때문이다. 하지만 멀티드롭 어드레싱 역시 매우 훌륭한 설계상의 결정이었던 것으로 드러났다. 다음과 같은 교훈을 얻을 수 있었다.
**14.어떤 도구든지 기대하는 방법으로 쓸모가 있어야 하지만 정말 위대한 도구는 사용자가 전혀 기대하지 않았던 용도에 알맞게 된다. (Any tool should be useful in the expected way, but a truly great tool lends itself to uses you never expected)**
미처 생각하지 못했던 멀티드롭 fetchmail 의 용도는 메일링리스트를 그대로 유지한 채, 알리아스 확장이 된 채로 SLIP/PPP로 연결된 클라이언트 쪽에서 메일링리스트를 운영하는 것이었다. 개인의 컴퓨터로 ISP 계정을 통해 접속하는 사람이 ISP 의 알리아스 파일에 지속적으로 접근하지 않고도 메일링리스트를 운영할 수 있다는 것을 의미한다.
베타테스터들이 요구한 중요한 변경사항중 또 하나는 8비트 MIME 오퍼레이션이었다. 이것은 내가 코드를 8비트에 대비하여 계속 유지시켜왔기 때문에 매우 쉬운 일이었다. 이런 기능에 대한 요구를 미리 예측해서 그랬던 것은 아니다. 다음과 같은 규칙을 따르려고 해서였다.
**15.어떤 종류든 게이트웨이 소프트웨어를 만들려고 한다면 데이터 스트림에 가능한 한 최소한의 조작만 가하라  그리고 수신자가 강제로 하게 하지 않는다면 정보를 *절대로* 잘라버리지 말라. (When writing gateway software of any kind, take pains to disturb the data stream as little as possible -- and *never* throw away informtion unless the recipient forces you to!)**
이 규칙을 따르지 않았다면 8비트 MIME 지원은 매우 어려웠을 것이며 많은 버그를 만들어 냈으리라. 규칙을 따랐기 때문에 내가 해야 할 일은 RFC 1652 를 읽고 헤더 생성 로직을 약간 수정하는 것 뿐이었다.
유럽의 몇몇 사용자들은 한 세션에서 가져올 수 있는 메시지의 수를 제한하도록 옵션을 추가해달라고 요구해왔다.(전화 네트워크의 비싼 비용을 조절할 수 있도록 해달라는 말이다) 오랫동안 여기에 저항했고, 아직도 완전히 수긍하지 못했다. 하지만 세계를 상대로 프로그램을 만든다면 고객들의 소리에 귀를 기울여야 한다 그들이 돈을 지불하지 않는다고 해도 마찬가지다.



<!-- A Few More Lessons from Fetchmail -->
__8.Fetchmail에서 배울 점__
----
일반적인 소프트웨어공학의 주제로 돌아가기 전에 fetchmail의 경험으로부터 배울 점이 몇 가지 더 있다. rc 파일의 구문은 선택사항으로 `noise' 라는 키워드를 포함하는데 이것은 파서에 의해 무시된다. rc 파일에서 허용하는 영어와 비슷한 구문은 잘라낼 것을 모두 잘라낸 후에 얻는 전통적이고 간명한 키워드-밸류 짝에 비해 훨씬 알아보기 쉽다.

이것은 내가 rc 파일의 선언들이 명령형 소언어 (imperative minilanguage)를 얼마나 많이 닮아가기 시작했는지 알아차리고 나서 한밤중의 실험으로 시작되었다. (popclient 의 "server" 라는 키워드를 "poll" 로 바꾼 이유도 이것이다)

명령형 소언어를 더 영어처럼 만들면 사용하기 쉬울 것으로 보였다. 지금은 내가 비록 Emacs 나 HTML, 그리고 많은 데이터베이스 엔진에서 볼 수 있듯이 설계를 할 때 "언어처럼 만드는" 파의 일원이긴 하지만 ``영어와 비슷한'' 구분을 가지는 것에 대해서는 그다지 달가와 하지 않는다.

전통적인 프로그래머들은 정확하고 짧으며 중복을 허용하지 않는 제어구문을 선호하는 경향이 있다. 이것은 컴퓨팅 자원이 비싸서 파싱하는 단계가 최대한 싸고 간단해야 했을 때부터 내려온 문화적 유산이다. 영어는 대략 50% 정도의 중복을 허용하므로 대단히 부적절한 모델인 것으로 보인다.

이것이 내가 영어와 비슷한 구문을 일반적으로 피하는 이유는 아니다. 이 문제를 언급한 이유는 그런 관습을 없애기 위해서다. 사이클과 코어의 값이 싸졌는데도 간명함은 저절로 없어지지는 않았다. 최근에는 언어가 컴퓨터의 관점에서 싼 가격이라는 점보다는 사람에게 편리한가 하는 점이 더 중요하다.

물론 조심해야 할 이유는 충분히 있다. 한 가지는 파싱하는 단계의 복잡성에 대한 비용이다 -- 파싱하는 단계를 버그가 우글거리는 데다가 사용자로 하여금 그 자체만으로 혼란을 일으키게 만들고 싶지는 않을 것이다. 또 하나의 이유는 언어의 구문을 영어와 비슷하게 만들려고 노력하면 그 "영어" 가 심각하게 왜곡되어 자연어와의 피상적인 유사점이 전통적인 구문만큼이나 혼란스럽게 되는 경우가 많다는 점이다. (소위 ``4세대'' 언어와 상업용 데이터베이스 질의어에서 이런 경우를 많이 볼 수 있다)

fetchmail 제어구문은 이런 문제를 피하려고 했다. 언어의 영역이 매우 제한되어 있었기 때문이다. 일반적인 목적의 언어와는 거리가 멀었다. 언어가 표현하는 것이 별로 복잡하지 않았기 때문에 영어의 일부분에서 실제 제어언어로 옮겨가는데 혼란을 일으킬 가능성이 적었다. 더 넓은 의미의 교훈을 여기에서 얻었다.

**16.언어가 튜링-컴플리트하지 않다면 구문상의 유연성이 필요하다. (When your language is nowhere near Turing-complete, syntactic sugar can be your friend)**

또하나의 교훈은 불투명함에 의한 보안에 대해서이다. fetchmail 의 사용자 중에는 스누퍼들이 우연히 패스워드를 보지 못하도록 rc 파일에 있는 패스워드를 암호화하여 가지고 있게 하자고 이야기하는 사람들이 있었다.

나는 그 이야기를 받아들이지 않았는데, 그렇게 한다고 해서 보안이 강화되는 것이 아니기 때문이다. rc 파일의 읽기 퍼미션을 얻은 사람이라면 사용자와 마찬가지로 fetchmail을 실행시킬 수도 있는 것이다 -- 그리고 그들이 패스워드를 원하는 것이라면 패스워드를 얻기 위해 fetchmail 코드에서 디코딩하는 코드를 뽑아낼 수도 있다.

.fetchmailrc 의 패스워드를 암호화 했다면 사람들은 그리 심각하게 생각하지도 않고 보안에 대해 잘못된 관념을 가지게 되었을 것이다. 여기서 알 수 있는 일반적인 규칙은 다음과 같다.

**17.보안시스템은 그것이 보호하려고 하는 비밀만큼만 안전하다. 가짜 비밀들에 주의할 것. (A security system is only as secure as its secret. Beware of pseudo-secrets)**


<!-- Necessary Preconditions for the Bazaar Style -->



<!-- The Social Context of Open-Source Software -->
